{
  "permissions": {
    "allow": [
      "Bash(gh repo view:*)",
      "Bash(git --version:*)",
      "Bash(git clone:*)",
      "Bash(npm install)",
      "Bash(npm run dev:*)",
      "Bash(vercel:*)",
      "Bash(npm install:*)",
      "Bash(taskkill:*)",
      "Bash(git pull:*)",
      "Bash(npx prisma:*)",
      "Bash(git add:*)",
      "Bash(git commit -m \"$\\(cat <<''EOF''\nFix localhost development: auth cookie, middleware subdomain bypass, login redirect\n\n- Use non-secure cookie name in development \\(localhost rejects __Secure- prefix over HTTP\\)\n- Skip subdomain checks on localhost, use DEV_TENANT_SLUG for tenant context\n- Redirect to /dashboard directly on localhost after login\n- Fix production fallback domain from localhost:3000 to omnixia.vercel.app\n- Add .vercel to .gitignore\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n\\)\")",
      "Bash(git push:*)",
      "Bash(find:*)",
      "Bash(curl:*)",
      "Bash(git commit:*)",
      "Bash(tasklist:*)",
      "Bash(findstr:*)",
      "Bash(powershell:*)",
      "Bash(timeout:*)",
      "Bash(npx next build)",
      "Bash(netstat:*)",
      "Bash(npx next dev:*)",
      "WebFetch(domain:muz.li)",
      "WebFetch(domain:www.thefrontendcompany.com)",
      "Bash(for file in \"src/app/dashboard/page.tsx\" \"src/app/daily/page.tsx\" \"src/app/dashboard/hr/page.tsx\" \"src/app/lead-qualifier/page.tsx\" \"src/app/clients/page.tsx\" \"src/app/projects/page.tsx\" \"src/app/tasks/page.tsx\" \"src/app/notes/page.tsx\" \"src/app/finance/page.tsx\" \"src/app/media/page.tsx\" \"src/app/timesheet/page.tsx\" \"src/app/team/page.tsx\" \"src/app/agencies/page.tsx\" \"src/app/analytics/page.tsx\" \"src/app/settings/page.tsx\")",
      "Bash(do wc -l \"$file\")",
      "Bash(done)",
      "Bash(node -e:*)",
      "Bash(npx tsc:*)",
      "Bash(ls:*)",
      "Bash(npm run build:*)",
      "Bash(got null instead\" because some client_team_members rows reference\ndeleted clients. Making the relation optional prevents the crash.\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n\\)\")",
      "Bash(1 <<'EOF'\n-- Create client_key_dates table\nCREATE TABLE IF NOT EXISTS client_key_dates \\(\n  id TEXT PRIMARY KEY DEFAULT gen_random_uuid\\(\\)::text,\n  \"clientId\" TEXT NOT NULL,\n  name TEXT NOT NULL,\n  date DATE NOT NULL,\n  \"endDate\" DATE,\n  \"isRecurring\" BOOLEAN DEFAULT true,\n  category TEXT DEFAULT 'HOLIDAY',\n  color TEXT,\n  notes TEXT,\n  \"createdAt\" TIMESTAMP\\(6\\) DEFAULT NOW\\(\\),\n  \"updatedAt\" TIMESTAMP\\(6\\) DEFAULT NOW\\(\\),\n  FOREIGN KEY \\(\"clientId\"\\) REFERENCES clients\\(id\\) ON DELETE CASCADE\n\\);\n\n-- Create indexes for client_key_dates\nCREATE INDEX IF NOT EXISTS idx_client_key_dates_client ON client_key_dates\\(\"clientId\"\\);\nCREATE INDEX IF NOT EXISTS idx_client_key_dates_date ON client_key_dates\\(date\\);\n\n-- Create key_date_templates table\nCREATE TABLE IF NOT EXISTS key_date_templates \\(\n  id TEXT PRIMARY KEY DEFAULT gen_random_uuid\\(\\)::text,\n  name TEXT NOT NULL,\n  region TEXT NOT NULL,\n  date TEXT NOT NULL,\n  \"isRecurring\" BOOLEAN DEFAULT true,\n  category TEXT DEFAULT 'HOLIDAY',\n  color TEXT,\n  \"createdAt\" TIMESTAMP\\(6\\) DEFAULT NOW\\(\\)\n\\);\n\n-- Create index for key_date_templates\nCREATE INDEX IF NOT EXISTS idx_key_date_templates_region ON key_date_templates\\(region\\);\nEOF)",
      "Bash(1 <<'EOF'\n-- Insert regional template key dates\n-- GCC National Days\nINSERT INTO key_date_templates \\(id, name, region, date, category, color, \"isRecurring\"\\) VALUES\n\\('tpl-qatar-nd', 'Qatar National Day', 'GCC', '12-18', 'HOLIDAY', '#8b1538', true\\),\n\\('tpl-uae-nd', 'UAE National Day', 'GCC', '12-02', 'HOLIDAY', '#00732f', true\\),\n\\('tpl-saudi-nd', 'Saudi National Day', 'GCC', '09-23', 'HOLIDAY', '#006c35', true\\),\n\\('tpl-kuwait-nd', 'Kuwait National Day', 'GCC', '02-25', 'HOLIDAY', '#007a3d', true\\),\n\\('tpl-bahrain-nd', 'Bahrain National Day', 'GCC', '12-16', 'HOLIDAY', '#ce1126', true\\),\n\\('tpl-oman-nd', 'Oman National Day', 'GCC', '11-18', 'HOLIDAY', '#db161b', true\\)\nON CONFLICT \\(id\\) DO NOTHING;\n\n-- Islamic/Religious dates \\(approximate, varies by moon\\)\nINSERT INTO key_date_templates \\(id, name, region, date, category, color, \"isRecurring\"\\) VALUES\n\\('tpl-eid-fitr', 'Eid Al-Fitr', 'Islamic', '04-10', 'RELIGIOUS', '#8b5cf6', true\\),\n\\('tpl-eid-adha', 'Eid Al-Adha', 'Islamic', '06-17', 'RELIGIOUS', '#8b5cf6', true\\),\n\\('tpl-ramadan', 'Ramadan Begins', 'Islamic', '03-11', 'RELIGIOUS', '#8b5cf6', true\\),\n\\('tpl-islamic-ny', 'Islamic New Year', 'Islamic', '07-08', 'RELIGIOUS', '#8b5cf6', true\\),\n\\('tpl-prophets-bday', 'Prophet Birthday \\(Mawlid\\)', 'Islamic', '09-16', 'RELIGIOUS', '#8b5cf6', true\\)\nON CONFLICT \\(id\\) DO NOTHING;\n\n-- Global/International dates\nINSERT INTO key_date_templates \\(id, name, region, date, category, color, \"isRecurring\"\\) VALUES\n\\('tpl-new-year', 'New Year Day', 'Global', '01-01', 'HOLIDAY', '#f59e0b', true\\),\n\\('tpl-valentines', 'Valentines Day', 'Global', '02-14', 'EVENT', '#ec4899', true\\),\n\\('tpl-womens-day', 'International Womens Day', 'Global', '03-08', 'EVENT', '#ec4899', true\\),\n\\('tpl-mothers-day', 'Mothers Day', 'Global', '03-21', 'EVENT', '#ec4899', true\\),\n\\('tpl-earth-day', 'Earth Day', 'Global', '04-22', 'EVENT', '#10b981', true\\),\n\\('tpl-labor-day', 'Labor Day', 'Global', '05-01', 'HOLIDAY', '#f59e0b', true\\),\n\\('tpl-fathers-day', 'Fathers Day', 'Global', '06-21', 'EVENT', '#06b6d4', true\\),\n\\('tpl-black-friday', 'Black Friday', 'Global', '11-29', 'CAMPAIGN', '#1f2937', true\\),\n\\('tpl-christmas', 'Christmas Day', 'Global', '12-25', 'HOLIDAY', '#dc2626', true\\),\n\\('tpl-new-year-eve', 'New Years Eve', 'Global', '12-31', 'EVENT', '#f59e0b', true\\)\nON CONFLICT \\(id\\) DO NOTHING;\n\n-- Levant region specific\nINSERT INTO key_date_templates \\(id, name, region, date, category, color, \"isRecurring\"\\) VALUES\n\\('tpl-lebanon-ind', 'Lebanon Independence Day', 'Levant', '11-22', 'HOLIDAY', '#00a651', true\\),\n\\('tpl-jordan-ind', 'Jordan Independence Day', 'Levant', '05-25', 'HOLIDAY', '#007a3d', true\\)\nON CONFLICT \\(id\\) DO NOTHING;\nEOF)",
      "Bash(identify:*)",
      "Bash(\"C:\\\\Users\\\\mbonm\\\\OneDrive\\\\Desktop\\\\clean in lebanon\\\\ai.withmb\\\\claude\\\\wick-portal-v2\\\\src\\\\app\\\\api\\\\tasks\\\\[id]\\\\watchers\\\\route.ts\")",
      "Bash(grep:*)",
      "Bash(dir:*)",
      "Bash(gh repo list:*)",
      "WebFetch(domain:www.omnixia.ai)",
      "Bash(gh auth:*)",
      "Bash(python3:*)",
      "Bash(python skills/ui-ux-pro-max/scripts/search.py:*)",
      "WebFetch(domain:docs.google.com)",
      "Bash(npx next build:*)",
      "Bash(cd:*)",
      "WebFetch(domain:thewickfirm.com)",
      "Bash(npx next lint:*)",
      "Bash(git status:*)",
      "Bash(git diff:*)",
      "Bash(pip install:*)",
      "Bash(python:*)",
      "Bash(npm ls:*)",
      "Bash(PGPASSWORD=\"WGVHmVFft5sVpR9n\" psql:*)",
      "WebFetch(domain:docs.anthropic.com)",
      "Bash(1 <<'SQL'\n-- SEO Tables\nCREATE TABLE IF NOT EXISTS seo_projects \\(\n  id TEXT PRIMARY KEY DEFAULT gen_random_uuid\\(\\)::text,\n  agency_id TEXT NOT NULL,\n  client_id TEXT NOT NULL REFERENCES clients\\(id\\) ON DELETE CASCADE,\n  name TEXT NOT NULL,\n  domain TEXT NOT NULL,\n  description TEXT,\n  status TEXT NOT NULL DEFAULT 'ACTIVE',\n  created_by TEXT NOT NULL,\n  created_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\),\n  updated_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\)\n\\);\nCREATE INDEX IF NOT EXISTS idx_seo_projects_agency ON seo_projects\\(agency_id\\);\nCREATE INDEX IF NOT EXISTS idx_seo_projects_client ON seo_projects\\(client_id\\);\nCREATE INDEX IF NOT EXISTS idx_seo_projects_status ON seo_projects\\(status\\);\n\nCREATE TABLE IF NOT EXISTS seo_keywords \\(\n  id TEXT PRIMARY KEY DEFAULT gen_random_uuid\\(\\)::text,\n  project_id TEXT NOT NULL REFERENCES seo_projects\\(id\\) ON DELETE CASCADE,\n  keyword TEXT NOT NULL,\n  search_volume INTEGER,\n  difficulty INTEGER,\n  current_rank INTEGER,\n  previous_rank INTEGER,\n  target_rank INTEGER,\n  intent TEXT,\n  category TEXT,\n  url TEXT,\n  status TEXT NOT NULL DEFAULT 'TRACKING',\n  rank_history JSONB NOT NULL DEFAULT '[]',\n  last_checked TIMESTAMP\\(6\\),\n  created_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\),\n  updated_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\)\n\\);\nCREATE INDEX IF NOT EXISTS idx_seo_keywords_project ON seo_keywords\\(project_id\\);\nCREATE INDEX IF NOT EXISTS idx_seo_keywords_keyword ON seo_keywords\\(keyword\\);\nCREATE INDEX IF NOT EXISTS idx_seo_keywords_status ON seo_keywords\\(status\\);\n\nCREATE TABLE IF NOT EXISTS seo_audits \\(\n  id TEXT PRIMARY KEY DEFAULT gen_random_uuid\\(\\)::text,\n  project_id TEXT NOT NULL REFERENCES seo_projects\\(id\\) ON DELETE CASCADE,\n  url TEXT NOT NULL,\n  page_title TEXT,\n  overall_score INTEGER,\n  performance_score INTEGER,\n  seo_score INTEGER,\n  accessibility_score INTEGER,\n  issues JSONB NOT NULL DEFAULT '[]',\n  meta_data JSONB,\n  status TEXT NOT NULL DEFAULT 'COMPLETED',\n  ai_suggestions TEXT,\n  created_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\),\n  updated_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\)\n\\);\nCREATE INDEX IF NOT EXISTS idx_seo_audits_project ON seo_audits\\(project_id\\);\nCREATE INDEX IF NOT EXISTS idx_seo_audits_url ON seo_audits\\(url\\);\n\nCREATE TABLE IF NOT EXISTS seo_pages \\(\n  id TEXT PRIMARY KEY DEFAULT gen_random_uuid\\(\\)::text,\n  project_id TEXT NOT NULL REFERENCES seo_projects\\(id\\) ON DELETE CASCADE,\n  url TEXT NOT NULL,\n  title TEXT,\n  meta_description TEXT,\n  h1 TEXT,\n  word_count INTEGER,\n  indexable BOOLEAN NOT NULL DEFAULT true,\n  target_keyword TEXT,\n  content_score INTEGER,\n  last_crawled TIMESTAMP\\(6\\),\n  ai_recommendations TEXT,\n  created_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\),\n  updated_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\)\n\\);\nCREATE INDEX IF NOT EXISTS idx_seo_pages_project ON seo_pages\\(project_id\\);\nCREATE INDEX IF NOT EXISTS idx_seo_pages_url ON seo_pages\\(url\\);\n\n-- AEO Tables\nCREATE TABLE IF NOT EXISTS aeo_projects \\(\n  id TEXT PRIMARY KEY DEFAULT gen_random_uuid\\(\\)::text,\n  agency_id TEXT NOT NULL,\n  client_id TEXT NOT NULL REFERENCES clients\\(id\\) ON DELETE CASCADE,\n  name TEXT NOT NULL,\n  domain TEXT NOT NULL,\n  industry TEXT,\n  description TEXT,\n  status TEXT NOT NULL DEFAULT 'ACTIVE',\n  created_by TEXT NOT NULL,\n  created_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\),\n  updated_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\)\n\\);\nCREATE INDEX IF NOT EXISTS idx_aeo_projects_agency ON aeo_projects\\(agency_id\\);\nCREATE INDEX IF NOT EXISTS idx_aeo_projects_client ON aeo_projects\\(client_id\\);\nCREATE INDEX IF NOT EXISTS idx_aeo_projects_status ON aeo_projects\\(status\\);\n\nCREATE TABLE IF NOT EXISTS aeo_queries \\(\n  id TEXT PRIMARY KEY DEFAULT gen_random_uuid\\(\\)::text,\n  project_id TEXT NOT NULL REFERENCES aeo_projects\\(id\\) ON DELETE CASCADE,\n  query TEXT NOT NULL,\n  category TEXT,\n  intent TEXT,\n  chatgpt_mentioned BOOLEAN NOT NULL DEFAULT false,\n  chatgpt_response TEXT,\n  chatgpt_position INTEGER,\n  claude_mentioned BOOLEAN NOT NULL DEFAULT false,\n  claude_response TEXT,\n  claude_position INTEGER,\n  gemini_mentioned BOOLEAN NOT NULL DEFAULT false,\n  gemini_response TEXT,\n  gemini_position INTEGER,\n  perplexity_mentioned BOOLEAN NOT NULL DEFAULT false,\n  perplexity_response TEXT,\n  perplexity_position INTEGER,\n  competitors_mentioned JSONB NOT NULL DEFAULT '[]',\n  optimization_score INTEGER,\n  recommendations JSONB NOT NULL DEFAULT '[]',\n  status TEXT NOT NULL DEFAULT 'TRACKED',\n  last_checked TIMESTAMP\\(6\\),\n  check_history JSONB NOT NULL DEFAULT '[]',\n  created_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\),\n  updated_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\)\n\\);\nCREATE INDEX IF NOT EXISTS idx_aeo_queries_project ON aeo_queries\\(project_id\\);\nCREATE INDEX IF NOT EXISTS idx_aeo_queries_status ON aeo_queries\\(status\\);\n\nCREATE TABLE IF NOT EXISTS aeo_analyses \\(\n  id TEXT PRIMARY KEY DEFAULT gen_random_uuid\\(\\)::text,\n  project_id TEXT NOT NULL REFERENCES aeo_projects\\(id\\) ON DELETE CASCADE,\n  overall_score INTEGER,\n  chatgpt_score INTEGER,\n  claude_score INTEGER,\n  gemini_score INTEGER,\n  perplexity_score INTEGER,\n  total_queries INTEGER NOT NULL DEFAULT 0,\n  mentioned_count INTEGER NOT NULL DEFAULT 0,\n  top_position INTEGER,\n  strengths JSONB NOT NULL DEFAULT '[]',\n  weaknesses JSONB NOT NULL DEFAULT '[]',\n  opportunities JSONB NOT NULL DEFAULT '[]',\n  ai_report TEXT,\n  period TEXT,\n  created_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\)\n\\);\nCREATE INDEX IF NOT EXISTS idx_aeo_analyses_project ON aeo_analyses\\(project_id\\);\nCREATE INDEX IF NOT EXISTS idx_aeo_analyses_created ON aeo_analyses\\(created_at\\);\nSQL)",
      "Bash(1 <<'SQL'\n-- Add new columns to seo_keywords\nALTER TABLE seo_keywords ADD COLUMN IF NOT EXISTS cpc DOUBLE PRECISION;\nALTER TABLE seo_keywords ADD COLUMN IF NOT EXISTS trend JSONB;\nALTER TABLE seo_keywords ADD COLUMN IF NOT EXISTS source TEXT;\n\n-- Recreate seo_pages with all new fields \\(drop and recreate since it's empty\\)\nDROP TABLE IF EXISTS seo_pages CASCADE;\nCREATE TABLE seo_pages \\(\n  id TEXT PRIMARY KEY DEFAULT gen_random_uuid\\(\\)::text,\n  project_id TEXT NOT NULL REFERENCES seo_projects\\(id\\) ON DELETE CASCADE,\n  url TEXT NOT NULL,\n  status_code INTEGER,\n  content_type TEXT,\n  indexable BOOLEAN NOT NULL DEFAULT true,\n  title TEXT,\n  title_length INTEGER,\n  meta_description TEXT,\n  meta_desc_length INTEGER,\n  h1 TEXT,\n  h1_count INTEGER,\n  h2 TEXT,\n  h2_count INTEGER,\n  canonical TEXT,\n  meta_robots TEXT,\n  word_count INTEGER,\n  text_ratio DOUBLE PRECISION,\n  response_time INTEGER,\n  content_size INTEGER,\n  lighthouse_performance INTEGER,\n  lighthouse_seo INTEGER,\n  lighthouse_accessibility INTEGER,\n  lighthouse_best_practices INTEGER,\n  core_web_vitals JSONB,\n  internal_links INTEGER,\n  external_links INTEGER,\n  inlinks INTEGER,\n  total_images INTEGER,\n  images_no_alt INTEGER,\n  has_schema_org BOOLEAN NOT NULL DEFAULT false,\n  schema_types JSONB,\n  og_title TEXT,\n  og_description TEXT,\n  og_image TEXT,\n  redirect_url TEXT,\n  depth INTEGER,\n  last_crawled TIMESTAMP\\(6\\),\n  import_id TEXT,\n  target_keyword TEXT,\n  content_score INTEGER,\n  ai_recommendations TEXT,\n  created_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\),\n  updated_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\)\n\\);\nCREATE INDEX IF NOT EXISTS idx_seo_pages_project ON seo_pages\\(project_id\\);\nCREATE INDEX IF NOT EXISTS idx_seo_pages_url ON seo_pages\\(url\\);\nCREATE INDEX IF NOT EXISTS idx_seo_pages_status_code ON seo_pages\\(status_code\\);\n\n-- Create seo_fixes\nCREATE TABLE IF NOT EXISTS seo_fixes \\(\n  id TEXT PRIMARY KEY DEFAULT gen_random_uuid\\(\\)::text,\n  project_id TEXT NOT NULL REFERENCES seo_projects\\(id\\) ON DELETE CASCADE,\n  page_id TEXT REFERENCES seo_pages\\(id\\) ON DELETE SET NULL,\n  page_url TEXT NOT NULL,\n  fix_type TEXT NOT NULL,\n  priority TEXT NOT NULL DEFAULT 'MEDIUM',\n  current_value TEXT,\n  proposed_value TEXT,\n  ai_generated BOOLEAN NOT NULL DEFAULT false,\n  status TEXT NOT NULL DEFAULT 'IDENTIFIED',\n  proposed_by TEXT,\n  proposed_at TIMESTAMP\\(6\\),\n  approved_by TEXT,\n  approved_at TIMESTAMP\\(6\\),\n  rejection_note TEXT,\n  implemented_at TIMESTAMP\\(6\\),\n  verified_at TIMESTAMP\\(6\\),\n  created_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\),\n  updated_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\)\n\\);\nCREATE INDEX IF NOT EXISTS idx_seo_fixes_project ON seo_fixes\\(project_id\\);\nCREATE INDEX IF NOT EXISTS idx_seo_fixes_status ON seo_fixes\\(status\\);\nCREATE INDEX IF NOT EXISTS idx_seo_fixes_type ON seo_fixes\\(fix_type\\);\nCREATE INDEX IF NOT EXISTS idx_seo_fixes_priority ON seo_fixes\\(priority\\);\n\n-- Create seo_imports\nCREATE TABLE IF NOT EXISTS seo_imports \\(\n  id TEXT PRIMARY KEY DEFAULT gen_random_uuid\\(\\)::text,\n  project_id TEXT NOT NULL REFERENCES seo_projects\\(id\\) ON DELETE CASCADE,\n  source TEXT NOT NULL,\n  file_name TEXT,\n  record_count INTEGER NOT NULL DEFAULT 0,\n  summary JSONB,\n  status TEXT NOT NULL DEFAULT 'COMPLETED',\n  error TEXT,\n  created_by TEXT NOT NULL,\n  created_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\)\n\\);\nCREATE INDEX IF NOT EXISTS idx_seo_imports_project ON seo_imports\\(project_id\\);\nCREATE INDEX IF NOT EXISTS idx_seo_imports_source ON seo_imports\\(source\\);\n\n-- Create seo_competitors\nCREATE TABLE IF NOT EXISTS seo_competitors \\(\n  id TEXT PRIMARY KEY DEFAULT gen_random_uuid\\(\\)::text,\n  project_id TEXT NOT NULL REFERENCES seo_projects\\(id\\) ON DELETE CASCADE,\n  name TEXT NOT NULL,\n  domain TEXT NOT NULL,\n  notes TEXT,\n  shared_keywords INTEGER,\n  keyword_gaps JSONB,\n  keyword_data JSONB,\n  created_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\),\n  updated_at TIMESTAMP\\(6\\) NOT NULL DEFAULT NOW\\(\\)\n\\);\nCREATE INDEX IF NOT EXISTS idx_seo_competitors_project ON seo_competitors\\(project_id\\);\nCREATE INDEX IF NOT EXISTS idx_seo_competitors_domain ON seo_competitors\\(domain\\);\nSQL)",
      "Bash(wc:*)",
      "WebFetch(domain:github.com)",
      "WebFetch(domain:raw.githubusercontent.com)",
      "WebFetch(domain:platform.openai.com)",
      "WebFetch(domain:ai.google.dev)",
      "WebFetch(domain:wavespeed.ai)",
      "WebFetch(domain:docs.wavespeed.ai)",
      "Bash(head:*)",
      "WebFetch(domain:docs.z.ai)",
      "WebFetch(domain:open.bigmodel.cn)",
      "WebFetch(domain:cloud.higgsfield.ai)",
      "WebFetch(domain:www.segmind.com)",
      "WebFetch(domain:apidog.com)",
      "WebFetch(domain:www.scribd.com)",
      "WebFetch(domain:unifically.com)",
      "WebFetch(domain:docs.unifically.com)",
      "Bash(\"C:/Users/mbonm/OneDrive/Desktop/clean in lebanon/ai.withmb/claude/wick-portal-v2/src/app/api/cdp/workspaces/[id]/profiles/route.ts\" << 'ENDOFFILE'\n// CDP Profiles — List & Create\n// Auth: Session \\(agency dashboard\\)\n\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { NextRequest, NextResponse } from \"next/server\";\nimport prisma from \"@/lib/prisma\";\n\nexport const dynamic = \"force-dynamic\";\n\nexport async function GET\\(\n  req: NextRequest,\n  { params }: { params: { id: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const url = new URL\\(req.url\\);\n    const page = parseInt\\(url.searchParams.get\\(\"page\"\\) || \"1\"\\);\n    const limit = Math.min\\(parseInt\\(url.searchParams.get\\(\"limit\"\\) || \"50\"\\), 100\\);\n    const search = url.searchParams.get\\(\"search\"\\) || \"\";\n    const isAnonymous = url.searchParams.get\\(\"isAnonymous\"\\);\n    const sortBy = url.searchParams.get\\(\"sortBy\"\\) || \"lastSeenAt\";\n    const sortOrder = url.searchParams.get\\(\"sortOrder\"\\) || \"desc\";\n\n    // Build where clause\n    const where: any = {\n      workspaceId: params.id,\n      mergedIntoId: null, // Only show canonical profiles\n    };\n\n    if \\(isAnonymous === \"true\"\\) where.isAnonymous = true;\n    if \\(isAnonymous === \"false\"\\) where.isAnonymous = false;\n\n    // Search across identities and traits\n    if \\(search\\) {\n      where.OR = [\n        { identities: { some: { identifierValue: { contains: search, mode: \"insensitive\" } } } },\n        { traits: { path: [\"email\"], string_contains: search } },\n        { traits: { path: [\"name\"], string_contains: search } },\n      ];\n    }\n\n    // Validate sort field\n    const validSortFields = [\"lastSeenAt\", \"firstSeenAt\", \"eventCount\", \"createdAt\"];\n    const sortField = validSortFields.includes\\(sortBy\\) ? sortBy : \"lastSeenAt\";\n\n    const [profiles, total] = await Promise.all\\([\n      prisma.cdpProfile.findMany\\({\n        where,\n        include: {\n          identities: {\n            select: {\n              identifierType: true,\n              identifierValue: true,\n            },\n          },\n          _count: {\n            select: {\n              events: true,\n              audienceMemberships: true,\n            },\n          },\n        },\n        orderBy: { [sortField]: sortOrder === \"asc\" ? \"asc\" : \"desc\" },\n        skip: \\(page - 1\\) * limit,\n        take: limit,\n      }\\),\n      prisma.cdpProfile.count\\({ where }\\),\n    ]\\);\n\n    return NextResponse.json\\({\n      profiles,\n      pagination: {\n        page,\n        limit,\n        total,\n        totalPages: Math.ceil\\(total / limit\\),\n      },\n    }\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_PROFILES_LIST]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to fetch profiles\" }, { status: 500 }\\);\n  }\n}\n\nexport async function POST\\(\n  req: NextRequest,\n  { params }: { params: { id: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const body = await req.json\\(\\);\n    const { userId, email, traits } = body;\n\n    if \\(!userId && !email\\) {\n      return NextResponse.json\\({ error: \"userId or email is required\" }, { status: 400 }\\);\n    }\n\n    // Create profile with identities\n    const profile = await prisma.cdpProfile.create\\({\n      data: {\n        workspaceId: params.id,\n        isAnonymous: false,\n        traits: traits || {},\n        identities: {\n          create: [\n            ...\\(userId ? [{ identifierType: \"user_id\", identifierValue: userId }] : []\\),\n            ...\\(email ? [{ identifierType: \"email\", identifierValue: email.toLowerCase\\(\\) }] : []\\),\n          ],\n        },\n      },\n      include: { identities: true },\n    }\\);\n\n    return NextResponse.json\\(profile, { status: 201 }\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_PROFILES_CREATE]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to create profile\" }, { status: 500 }\\);\n  }\n}\nENDOFFILE)",
      "Bash(\"C:/Users/mbonm/OneDrive/Desktop/clean in lebanon/ai.withmb/claude/wick-portal-v2/src/app/api/cdp/workspaces/[id]/profiles/[profileId]/route.ts\" << 'ENDOFFILE'\n// CDP Profile Detail — Customer 360 View\n// Auth: Session \\(agency dashboard\\)\n\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { NextRequest, NextResponse } from \"next/server\";\nimport prisma from \"@/lib/prisma\";\n\nexport const dynamic = \"force-dynamic\";\n\nexport async function GET\\(\n  req: NextRequest,\n  { params }: { params: { id: string; profileId: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const profile = await prisma.cdpProfile.findFirst\\({\n      where: { id: params.profileId, workspaceId: params.id },\n      include: {\n        identities: {\n          orderBy: { identifierType: \"asc\" },\n        },\n        mergedProfiles: {\n          select: { id: true, firstSeenAt: true, lastSeenAt: true, eventCount: true },\n        },\n        audienceMemberships: {\n          include: {\n            audience: {\n              select: { id: true, name: true, status: true },\n            },\n          },\n        },\n        consents: {\n          orderBy: { updatedAt: \"desc\" },\n        },\n        _count: {\n          select: { events: true },\n        },\n      },\n    }\\);\n\n    if \\(!profile\\) return NextResponse.json\\({ error: \"Profile not found\" }, { status: 404 }\\);\n\n    // Get recent events \\(last 20\\)\n    const recentEvents = await prisma.cdpEvent.findMany\\({\n      where: { profileId: params.profileId },\n      orderBy: { timestamp: \"desc\" },\n      take: 20,\n      include: {\n        source: { select: { name: true, type: true } },\n      },\n    }\\);\n\n    // Get event type breakdown\n    const eventBreakdown = await prisma.cdpEvent.groupBy\\({\n      by: [\"type\"],\n      where: { profileId: params.profileId },\n      _count: { type: true },\n    }\\);\n\n    return NextResponse.json\\({\n      profile,\n      recentEvents,\n      eventBreakdown: eventBreakdown.map\\(\\(e: any\\) => \\({\n        type: e.type,\n        count: e._count.type,\n      }\\)\\),\n    }\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_PROFILE_DETAIL]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to fetch profile\" }, { status: 500 }\\);\n  }\n}\n\nexport async function DELETE\\(\n  req: NextRequest,\n  { params }: { params: { id: string; profileId: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    // Delete profile \\(cascades to identities, events profileId becomes null\\)\n    await prisma.cdpProfile.delete\\({\n      where: { id: params.profileId },\n    }\\);\n\n    return NextResponse.json\\({ success: true }\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_PROFILE_DELETE]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to delete profile\" }, { status: 500 }\\);\n  }\n}\nENDOFFILE)",
      "Bash(\"C:/Users/mbonm/OneDrive/Desktop/clean in lebanon/ai.withmb/claude/wick-portal-v2/src/app/api/cdp/workspaces/[id]/profiles/[profileId]/events/route.ts\" << 'ENDOFFILE'\n// CDP Profile Events — Paginated event timeline for a profile\n// Auth: Session \\(agency dashboard\\)\n\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { NextRequest, NextResponse } from \"next/server\";\nimport prisma from \"@/lib/prisma\";\n\nexport const dynamic = \"force-dynamic\";\n\nexport async function GET\\(\n  req: NextRequest,\n  { params }: { params: { id: string; profileId: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const url = new URL\\(req.url\\);\n    const page = parseInt\\(url.searchParams.get\\(\"page\"\\) || \"1\"\\);\n    const limit = Math.min\\(parseInt\\(url.searchParams.get\\(\"limit\"\\) || \"50\"\\), 100\\);\n    const type = url.searchParams.get\\(\"type\"\\) || \"\";\n\n    const where: any = {\n      profileId: params.profileId,\n      workspaceId: params.id,\n    };\n    if \\(type\\) where.type = type;\n\n    const [events, total] = await Promise.all\\([\n      prisma.cdpEvent.findMany\\({\n        where,\n        include: {\n          source: { select: { name: true, type: true } },\n        },\n        orderBy: { timestamp: \"desc\" },\n        skip: \\(page - 1\\) * limit,\n        take: limit,\n      }\\),\n      prisma.cdpEvent.count\\({ where }\\),\n    ]\\);\n\n    return NextResponse.json\\({\n      events,\n      pagination: {\n        page,\n        limit,\n        total,\n        totalPages: Math.ceil\\(total / limit\\),\n      },\n    }\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_PROFILE_EVENTS]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to fetch profile events\" }, { status: 500 }\\);\n  }\n}\nENDOFFILE)",
      "Bash(\"C:/Users/mbonm/OneDrive/Desktop/clean in lebanon/ai.withmb/claude/wick-portal-v2/src/app/api/cdp/workspaces/[id]/profiles/[profileId]/recompute/route.ts\" << 'ENDOFFILE'\n// CDP Profile Recompute — Trigger computed traits recalculation\n// Auth: Session \\(agency dashboard\\)\n\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { NextRequest, NextResponse } from \"next/server\";\nimport prisma from \"@/lib/prisma\";\nimport { computeTraitsForProfile } from \"@/lib/cdp/computed-traits\";\n\nexport const dynamic = \"force-dynamic\";\n\nexport async function POST\\(\n  req: NextRequest,\n  { params }: { params: { id: string; profileId: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    // Verify profile exists\n    const profile = await prisma.cdpProfile.findFirst\\({\n      where: { id: params.profileId, workspaceId: params.id },\n    }\\);\n    if \\(!profile\\) return NextResponse.json\\({ error: \"Profile not found\" }, { status: 404 }\\);\n\n    const computed = await computeTraitsForProfile\\(params.profileId\\);\n\n    return NextResponse.json\\({ success: true, computedTraits: computed }\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_PROFILE_RECOMPUTE]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to recompute traits\" }, { status: 500 }\\);\n  }\n}\nENDOFFILE)",
      "Bash(\"C:/Users/mbonm/OneDrive/Desktop/clean in lebanon/ai.withmb/claude/wick-portal-v2/src/app/api/cdp/workspaces/[id]/profiles/stats/route.ts\" << 'ENDOFFILE'\n// CDP Profile Stats — Workspace-level profile statistics\n// Auth: Session \\(agency dashboard\\)\n\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { NextRequest, NextResponse } from \"next/server\";\nimport prisma from \"@/lib/prisma\";\n\nexport const dynamic = \"force-dynamic\";\n\nexport async function GET\\(\n  req: NextRequest,\n  { params }: { params: { id: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const [\n      totalProfiles,\n      knownProfiles,\n      anonymousProfiles,\n      mergedProfiles,\n      recentlyActive,\n      identityTypes,\n    ] = await Promise.all\\([\n      // Total active profiles\n      prisma.cdpProfile.count\\({\n        where: { workspaceId: params.id, mergedIntoId: null },\n      }\\),\n      // Known profiles\n      prisma.cdpProfile.count\\({\n        where: { workspaceId: params.id, mergedIntoId: null, isAnonymous: false },\n      }\\),\n      // Anonymous profiles\n      prisma.cdpProfile.count\\({\n        where: { workspaceId: params.id, mergedIntoId: null, isAnonymous: true },\n      }\\),\n      // Merged profiles \\(resolved\\)\n      prisma.cdpProfile.count\\({\n        where: { workspaceId: params.id, mergedIntoId: { not: null } },\n      }\\),\n      // Active in last 7 days\n      prisma.cdpProfile.count\\({\n        where: {\n          workspaceId: params.id,\n          mergedIntoId: null,\n          lastSeenAt: { gte: new Date\\(Date.now\\(\\) - 7 * 24 * 60 * 60 * 1000\\) },\n        },\n      }\\),\n      // Identity types breakdown\n      prisma.cdpIdentity.groupBy\\({\n        by: [\"identifierType\"],\n        where: {\n          profile: { workspaceId: params.id, mergedIntoId: null },\n        },\n        _count: { identifierType: true },\n      }\\),\n    ]\\);\n\n    return NextResponse.json\\({\n      totalProfiles,\n      knownProfiles,\n      anonymousProfiles,\n      mergedProfiles,\n      identificationRate: totalProfiles > 0\n        ? Math.round\\(\\(knownProfiles / totalProfiles\\) * 10000\\) / 100\n        : 0,\n      recentlyActive,\n      identityTypes: identityTypes.map\\(\\(t: any\\) => \\({\n        type: t.identifierType,\n        count: t._count.identifierType,\n      }\\)\\),\n    }\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_PROFILE_STATS]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to fetch profile stats\" }, { status: 500 }\\);\n  }\n}\nENDOFFILE)",
      "Bash(npx vercel inspect:*)",
      "Bash(npx vercel:*)",
      "Bash(test:*)",
      "Bash(node scripts/import-spotler.js:*)",
      "Bash(node scripts/check-constraints.js:*)",
      "Bash(node scripts/cleanup-failed.js:*)",
      "Bash(node scripts/test-insert.js:*)",
      "Bash(node scripts/import-spotler-resume.js:*)",
      "Bash(gh api:*)",
      "Bash(where:*)",
      "Bash(node --version:*)",
      "Bash(node scripts/run-cdp-migration.js:*)",
      "Bash(\"/c/Users/mbonm/OneDrive/Desktop/clean in lebanon/ai.withmb/claude/wick-portal-v2/src/app/api/cdp/workspaces/[id]/email-templates/route.ts\" << 'ENDOFFILE'\n// CDP Email Templates — List & Create\n// Auth: Session \\(agency dashboard\\)\n\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { NextRequest, NextResponse } from \"next/server\";\nimport prisma from \"@/lib/prisma\";\nimport cdpPrisma from \"@/lib/cdp-prisma\";\n\nexport const dynamic = \"force-dynamic\";\n\nexport async function GET\\(\n  req: NextRequest,\n  { params }: { params: { id: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const { searchParams } = new URL\\(req.url\\);\n    const status = searchParams.get\\(\"status\"\\);\n    const category = searchParams.get\\(\"category\"\\);\n\n    const templates = await cdpPrisma.cdpEmailTemplate.findMany\\({\n      where: {\n        workspaceId: params.id,\n        ...\\(status ? { status: status as any } : {}\\),\n        ...\\(category ? { category: category as any } : {}\\),\n      },\n      orderBy: { createdAt: \"desc\" },\n    }\\);\n\n    return NextResponse.json\\({ templates }\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_EMAIL_TEMPLATES_LIST]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to fetch email templates\" }, { status: 500 }\\);\n  }\n}\n\nexport async function POST\\(\n  req: NextRequest,\n  { params }: { params: { id: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true, id: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const body = await req.json\\(\\);\n    const { name, subject, htmlBody, textBody, preheader, variables, category, fromName, fromEmail, replyTo } = body;\n\n    if \\(!name || !subject\\) {\n      return NextResponse.json\\({ error: \"Name and subject are required\" }, { status: 400 }\\);\n    }\n\n    const template = await cdpPrisma.cdpEmailTemplate.create\\({\n      data: {\n        workspaceId: params.id,\n        name,\n        subject,\n        htmlBody: htmlBody || \"\",\n        textBody: textBody || null,\n        preheader: preheader || null,\n        variables: variables || [],\n        category: category || \"MARKETING\",\n        status: \"DRAFT\",\n        fromName: fromName || null,\n        fromEmail: fromEmail || null,\n        replyTo: replyTo || null,\n        createdBy: currentUser.id,\n      },\n    }\\);\n\n    return NextResponse.json\\(template, { status: 201 }\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_EMAIL_TEMPLATES_CREATE]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to create email template\" }, { status: 500 }\\);\n  }\n}\nENDOFFILE)",
      "Bash(\"/c/Users/mbonm/OneDrive/Desktop/clean in lebanon/ai.withmb/claude/wick-portal-v2/src/app/api/cdp/workspaces/[id]/email-templates/[templateId]/route.ts\" << 'ENDOFFILE'\n// CDP Email Template — Get, Update, Delete\n// Auth: Session \\(agency dashboard\\)\n\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { NextRequest, NextResponse } from \"next/server\";\nimport prisma from \"@/lib/prisma\";\nimport cdpPrisma from \"@/lib/cdp-prisma\";\n\nexport const dynamic = \"force-dynamic\";\n\nexport async function GET\\(\n  req: NextRequest,\n  { params }: { params: { id: string; templateId: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const template = await cdpPrisma.cdpEmailTemplate.findFirst\\({\n      where: { id: params.templateId, workspaceId: params.id },\n    }\\);\n    if \\(!template\\) return NextResponse.json\\({ error: \"Template not found\" }, { status: 404 }\\);\n\n    // Get recent send stats\n    const sendStats = await cdpPrisma.cdpEmailSend.groupBy\\({\n      by: [\"status\"],\n      where: { templateId: params.templateId },\n      _count: { status: true },\n    }\\);\n\n    return NextResponse.json\\({ template, sendStats }\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_EMAIL_TEMPLATE_GET]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to fetch email template\" }, { status: 500 }\\);\n  }\n}\n\nexport async function PUT\\(\n  req: NextRequest,\n  { params }: { params: { id: string; templateId: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const existing = await cdpPrisma.cdpEmailTemplate.findFirst\\({\n      where: { id: params.templateId, workspaceId: params.id },\n    }\\);\n    if \\(!existing\\) return NextResponse.json\\({ error: \"Template not found\" }, { status: 404 }\\);\n\n    const body = await req.json\\(\\);\n    const {\n      name, subject, htmlBody, textBody, preheader,\n      variables, category, status, fromName, fromEmail, replyTo,\n    } = body;\n\n    const template = await cdpPrisma.cdpEmailTemplate.update\\({\n      where: { id: params.templateId },\n      data: {\n        ...\\(name !== undefined ? { name } : {}\\),\n        ...\\(subject !== undefined ? { subject } : {}\\),\n        ...\\(htmlBody !== undefined ? { htmlBody } : {}\\),\n        ...\\(textBody !== undefined ? { textBody } : {}\\),\n        ...\\(preheader !== undefined ? { preheader } : {}\\),\n        ...\\(variables !== undefined ? { variables } : {}\\),\n        ...\\(category !== undefined ? { category } : {}\\),\n        ...\\(status !== undefined ? { status } : {}\\),\n        ...\\(fromName !== undefined ? { fromName } : {}\\),\n        ...\\(fromEmail !== undefined ? { fromEmail } : {}\\),\n        ...\\(replyTo !== undefined ? { replyTo } : {}\\),\n      },\n    }\\);\n\n    return NextResponse.json\\(template\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_EMAIL_TEMPLATE_UPDATE]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to update email template\" }, { status: 500 }\\);\n  }\n}\n\nexport async function DELETE\\(\n  req: NextRequest,\n  { params }: { params: { id: string; templateId: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const existing = await cdpPrisma.cdpEmailTemplate.findFirst\\({\n      where: { id: params.templateId, workspaceId: params.id },\n    }\\);\n    if \\(!existing\\) return NextResponse.json\\({ error: \"Template not found\" }, { status: 404 }\\);\n\n    // Soft delete by archiving \\(preserve for send history\\)\n    await cdpPrisma.cdpEmailTemplate.update\\({\n      where: { id: params.templateId },\n      data: { status: \"ARCHIVED\" },\n    }\\);\n\n    return NextResponse.json\\({ ok: true }\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_EMAIL_TEMPLATE_DELETE]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to delete email template\" }, { status: 500 }\\);\n  }\n}\nENDOFFILE)",
      "Bash(\"/c/Users/mbonm/OneDrive/Desktop/clean in lebanon/ai.withmb/claude/wick-portal-v2/src/app/api/cdp/workspaces/[id]/journeys/route.ts\" << 'ENDOFFILE'\n// CDP Journeys — List & Create\n// Auth: Session \\(agency dashboard\\)\n\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { NextRequest, NextResponse } from \"next/server\";\nimport prisma from \"@/lib/prisma\";\nimport cdpPrisma from \"@/lib/cdp-prisma\";\n\nexport const dynamic = \"force-dynamic\";\n\nexport async function GET\\(\n  req: NextRequest,\n  { params }: { params: { id: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const { searchParams } = new URL\\(req.url\\);\n    const status = searchParams.get\\(\"status\"\\);\n\n    const journeys = await cdpPrisma.cdpJourney.findMany\\({\n      where: {\n        workspaceId: params.id,\n        ...\\(status ? { status: status as any } : {}\\),\n      },\n      include: {\n        _count: {\n          select: { steps: true, enrollments: true },\n        },\n      },\n      orderBy: { createdAt: \"desc\" },\n    }\\);\n\n    return NextResponse.json\\({ journeys }\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_JOURNEYS_LIST]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to fetch journeys\" }, { status: 500 }\\);\n  }\n}\n\nexport async function POST\\(\n  req: NextRequest,\n  { params }: { params: { id: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true, id: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const body = await req.json\\(\\);\n    const { name, description, trigger, settings } = body;\n\n    if \\(!name\\) {\n      return NextResponse.json\\({ error: \"Name is required\" }, { status: 400 }\\);\n    }\n\n    const journey = await cdpPrisma.cdpJourney.create\\({\n      data: {\n        workspaceId: params.id,\n        name,\n        description: description || null,\n        status: \"DRAFT\",\n        trigger: trigger || {},\n        settings: settings || {},\n        stats: { entered: 0, active: 0, completed: 0, exited: 0, errored: 0 },\n        createdBy: currentUser.id,\n      },\n    }\\);\n\n    return NextResponse.json\\(journey, { status: 201 }\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_JOURNEYS_CREATE]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to create journey\" }, { status: 500 }\\);\n  }\n}\nENDOFFILE)",
      "Bash(\"/c/Users/mbonm/OneDrive/Desktop/clean in lebanon/ai.withmb/claude/wick-portal-v2/src/app/api/cdp/workspaces/[id]/journeys/[journeyId]/route.ts\" << 'ENDOFFILE'\n// CDP Journey — Get, Update \\(with steps save-all\\), Delete\n// Auth: Session \\(agency dashboard\\)\n\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { NextRequest, NextResponse } from \"next/server\";\nimport prisma from \"@/lib/prisma\";\nimport cdpPrisma from \"@/lib/cdp-prisma\";\n\nexport const dynamic = \"force-dynamic\";\n\nexport async function GET\\(\n  req: NextRequest,\n  { params }: { params: { id: string; journeyId: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const journey = await cdpPrisma.cdpJourney.findFirst\\({\n      where: { id: params.journeyId, workspaceId: params.id },\n      include: {\n        steps: { orderBy: { createdAt: \"asc\" } },\n        _count: { select: { enrollments: true } },\n      },\n    }\\);\n    if \\(!journey\\) return NextResponse.json\\({ error: \"Journey not found\" }, { status: 404 }\\);\n\n    // Get enrollment stats by status\n    const enrollmentStats = await cdpPrisma.cdpJourneyEnrollment.groupBy\\({\n      by: [\"status\"],\n      where: { journeyId: params.journeyId },\n      _count: { status: true },\n    }\\);\n\n    return NextResponse.json\\({ journey, enrollmentStats }\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_JOURNEY_GET]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to fetch journey\" }, { status: 500 }\\);\n  }\n}\n\nexport async function PUT\\(\n  req: NextRequest,\n  { params }: { params: { id: string; journeyId: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const existing = await cdpPrisma.cdpJourney.findFirst\\({\n      where: { id: params.journeyId, workspaceId: params.id },\n    }\\);\n    if \\(!existing\\) return NextResponse.json\\({ error: \"Journey not found\" }, { status: 404 }\\);\n\n    const body = await req.json\\(\\);\n    const { name, description, status, trigger, settings, steps } = body;\n\n    // Update journey metadata\n    const journey = await cdpPrisma.cdpJourney.update\\({\n      where: { id: params.journeyId },\n      data: {\n        ...\\(name !== undefined ? { name } : {}\\),\n        ...\\(description !== undefined ? { description } : {}\\),\n        ...\\(status !== undefined ? { status } : {}\\),\n        ...\\(trigger !== undefined ? { trigger } : {}\\),\n        ...\\(settings !== undefined ? { settings } : {}\\),\n      },\n    }\\);\n\n    // If steps are provided, do a save-all \\(delete + recreate\\)\n    if \\(steps && Array.isArray\\(steps\\)\\) {\n      // Delete existing steps\n      await cdpPrisma.cdpJourneyStep.deleteMany\\({\n        where: { journeyId: params.journeyId },\n      }\\);\n\n      // Create new steps\n      if \\(steps.length > 0\\) {\n        await cdpPrisma.cdpJourneyStep.createMany\\({\n          data: steps.map\\(\\(step: any\\) => \\({\n            journeyId: params.journeyId,\n            stepKey: step.stepKey,\n            type: step.type,\n            config: step.config || {},\n            nextStepKey: step.nextStepKey || null,\n            trueStepKey: step.trueStepKey || null,\n            falseStepKey: step.falseStepKey || null,\n            position: step.position || { x: 0, y: 0 },\n          }\\)\\),\n        }\\);\n      }\n    }\n\n    // Fetch updated journey with steps\n    const updated = await cdpPrisma.cdpJourney.findUnique\\({\n      where: { id: params.journeyId },\n      include: {\n        steps: { orderBy: { createdAt: \"asc\" } },\n        _count: { select: { enrollments: true } },\n      },\n    }\\);\n\n    return NextResponse.json\\(updated\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_JOURNEY_UPDATE]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to update journey\" }, { status: 500 }\\);\n  }\n}\n\nexport async function DELETE\\(\n  req: NextRequest,\n  { params }: { params: { id: string; journeyId: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const existing = await cdpPrisma.cdpJourney.findFirst\\({\n      where: { id: params.journeyId, workspaceId: params.id },\n    }\\);\n    if \\(!existing\\) return NextResponse.json\\({ error: \"Journey not found\" }, { status: 404 }\\);\n\n    // Don't allow deleting active journeys with active enrollments\n    if \\(existing.status === \"ACTIVE\"\\) {\n      const activeEnrollments = await cdpPrisma.cdpJourneyEnrollment.count\\({\n        where: {\n          journeyId: params.journeyId,\n          status: { in: [\"ACTIVE\", \"WAITING\"] },\n        },\n      }\\);\n      if \\(activeEnrollments > 0\\) {\n        return NextResponse.json\\(\n          { error: `Cannot delete active journey with ${activeEnrollments} active enrollment\\(s\\). Pause or archive first.` },\n          { status: 400 }\n        \\);\n      }\n    }\n\n    // Soft delete by archiving\n    await cdpPrisma.cdpJourney.update\\({\n      where: { id: params.journeyId },\n      data: { status: \"ARCHIVED\" },\n    }\\);\n\n    return NextResponse.json\\({ ok: true }\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_JOURNEY_DELETE]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to delete journey\" }, { status: 500 }\\);\n  }\n}\nENDOFFILE)",
      "Bash(\"/c/Users/mbonm/OneDrive/Desktop/clean in lebanon/ai.withmb/claude/wick-portal-v2/src/app/api/cdp/workspaces/[id]/personalizations/route.ts\" << 'ENDOFFILE'\n// CDP Personalizations — List & Create\n// Auth: Session \\(agency dashboard\\)\n\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { NextRequest, NextResponse } from \"next/server\";\nimport prisma from \"@/lib/prisma\";\nimport cdpPrisma from \"@/lib/cdp-prisma\";\n\nexport const dynamic = \"force-dynamic\";\n\nexport async function GET\\(\n  req: NextRequest,\n  { params }: { params: { id: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const { searchParams } = new URL\\(req.url\\);\n    const status = searchParams.get\\(\"status\"\\);\n    const type = searchParams.get\\(\"type\"\\);\n\n    const personalizations = await cdpPrisma.cdpPersonalization.findMany\\({\n      where: {\n        workspaceId: params.id,\n        ...\\(status ? { status: status as any } : {}\\),\n        ...\\(type ? { type: type as any } : {}\\),\n      },\n      orderBy: [{ priority: \"desc\" }, { createdAt: \"desc\" }],\n    }\\);\n\n    return NextResponse.json\\({ personalizations }\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_PERSONALIZATIONS_LIST]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to fetch personalizations\" }, { status: 500 }\\);\n  }\n}\n\nexport async function POST\\(\n  req: NextRequest,\n  { params }: { params: { id: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true, id: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const body = await req.json\\(\\);\n    const { name, description, type, rules, targeting, content, priority, startsAt, endsAt } = body;\n\n    if \\(!name\\) {\n      return NextResponse.json\\({ error: \"Name is required\" }, { status: 400 }\\);\n    }\n\n    const personalization = await cdpPrisma.cdpPersonalization.create\\({\n      data: {\n        workspaceId: params.id,\n        name,\n        description: description || null,\n        status: \"DRAFT\",\n        type: type || \"CUSTOM\",\n        rules: rules || { operator: \"AND\", rules: [] },\n        targeting: targeting || {},\n        content: content || {},\n        priority: priority || 0,\n        startsAt: startsAt ? new Date\\(startsAt\\) : null,\n        endsAt: endsAt ? new Date\\(endsAt\\) : null,\n        createdBy: currentUser.id,\n      },\n    }\\);\n\n    return NextResponse.json\\(personalization, { status: 201 }\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_PERSONALIZATIONS_CREATE]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to create personalization\" }, { status: 500 }\\);\n  }\n}\nENDOFFILE)",
      "Bash(\"/c/Users/mbonm/OneDrive/Desktop/clean in lebanon/ai.withmb/claude/wick-portal-v2/src/app/api/cdp/workspaces/[id]/personalizations/[personalizationId]/route.ts\" << 'ENDOFFILE'\n// CDP Personalization — Get, Update, Delete\n// Auth: Session \\(agency dashboard\\)\n\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { NextRequest, NextResponse } from \"next/server\";\nimport prisma from \"@/lib/prisma\";\nimport cdpPrisma from \"@/lib/cdp-prisma\";\n\nexport const dynamic = \"force-dynamic\";\n\nexport async function GET\\(\n  req: NextRequest,\n  { params }: { params: { id: string; personalizationId: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const personalization = await cdpPrisma.cdpPersonalization.findFirst\\({\n      where: { id: params.personalizationId, workspaceId: params.id },\n    }\\);\n    if \\(!personalization\\) return NextResponse.json\\({ error: \"Personalization not found\" }, { status: 404 }\\);\n\n    // Get interaction stats \\(last 30 days\\)\n    const thirtyDaysAgo = new Date\\(Date.now\\(\\) - 30 * 24 * 60 * 60 * 1000\\);\n    const interactionStats = await cdpPrisma.cdpPersonalizationLog.groupBy\\({\n      by: [\"action\"],\n      where: {\n        personalizationId: params.personalizationId,\n        createdAt: { gte: thirtyDaysAgo },\n      },\n      _count: { action: true },\n    }\\);\n\n    return NextResponse.json\\({ personalization, interactionStats }\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_PERSONALIZATION_GET]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to fetch personalization\" }, { status: 500 }\\);\n  }\n}\n\nexport async function PUT\\(\n  req: NextRequest,\n  { params }: { params: { id: string; personalizationId: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const existing = await cdpPrisma.cdpPersonalization.findFirst\\({\n      where: { id: params.personalizationId, workspaceId: params.id },\n    }\\);\n    if \\(!existing\\) return NextResponse.json\\({ error: \"Personalization not found\" }, { status: 404 }\\);\n\n    const body = await req.json\\(\\);\n    const {\n      name, description, status, type, rules, targeting,\n      content, priority, startsAt, endsAt,\n    } = body;\n\n    const personalization = await cdpPrisma.cdpPersonalization.update\\({\n      where: { id: params.personalizationId },\n      data: {\n        ...\\(name !== undefined ? { name } : {}\\),\n        ...\\(description !== undefined ? { description } : {}\\),\n        ...\\(status !== undefined ? { status } : {}\\),\n        ...\\(type !== undefined ? { type } : {}\\),\n        ...\\(rules !== undefined ? { rules } : {}\\),\n        ...\\(targeting !== undefined ? { targeting } : {}\\),\n        ...\\(content !== undefined ? { content } : {}\\),\n        ...\\(priority !== undefined ? { priority } : {}\\),\n        ...\\(startsAt !== undefined ? { startsAt: startsAt ? new Date\\(startsAt\\) : null } : {}\\),\n        ...\\(endsAt !== undefined ? { endsAt: endsAt ? new Date\\(endsAt\\) : null } : {}\\),\n      },\n    }\\);\n\n    return NextResponse.json\\(personalization\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_PERSONALIZATION_UPDATE]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to update personalization\" }, { status: 500 }\\);\n  }\n}\n\nexport async function DELETE\\(\n  req: NextRequest,\n  { params }: { params: { id: string; personalizationId: string } }\n\\) {\n  try {\n    const session = await getServerSession\\(authOptions\\);\n    if \\(!session\\) return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n\n    const user = session.user as any;\n    const currentUser = await prisma.user.findUnique\\({\n      where: { email: user.email },\n      select: { agencyId: true },\n    }\\);\n    if \\(!currentUser?.agencyId\\) return NextResponse.json\\({ error: \"No agency context\" }, { status: 403 }\\);\n\n    const workspace = await prisma.cdpWorkspace.findFirst\\({\n      where: { id: params.id, agencyId: currentUser.agencyId },\n    }\\);\n    if \\(!workspace\\) return NextResponse.json\\({ error: \"Workspace not found\" }, { status: 404 }\\);\n\n    const existing = await cdpPrisma.cdpPersonalization.findFirst\\({\n      where: { id: params.personalizationId, workspaceId: params.id },\n    }\\);\n    if \\(!existing\\) return NextResponse.json\\({ error: \"Personalization not found\" }, { status: 404 }\\);\n\n    // Soft delete by archiving\n    await cdpPrisma.cdpPersonalization.update\\({\n      where: { id: params.personalizationId },\n      data: { status: \"ARCHIVED\" },\n    }\\);\n\n    return NextResponse.json\\({ ok: true }\\);\n  } catch \\(error: any\\) {\n    console.error\\(\"[CDP_PERSONALIZATION_DELETE]\", error\\);\n    return NextResponse.json\\({ error: \"Failed to delete personalization\" }, { status: 500 }\\);\n  }\n}\nENDOFFILE)",
      "Bash(node scripts/write-ui-pages.js:*)",
      "Bash(node scripts/write-email-new.js:*)",
      "Bash(node scripts/write-email-detail.js:*)",
      "Bash(node scripts/write-journey-pages.js:*)",
      "Bash(node scripts/write-pz-pages.js:*)",
      "Bash(git log:*)",
      "WebFetch(domain:docs.dataforseo.com)",
      "WebFetch(domain:dataforseo.com)",
      "WebFetch(domain:developers.google.com)",
      "Bash(git fetch:*)",
      "Bash(git branch:*)",
      "Bash(git merge:*)",
      "Bash(explorer:*)",
      "Bash(cmd.exe /c explorer \"C:\\\\Users\\\\mbonm\\\\OneDrive\\\\Desktop\\\\clean in lebanon\\\\ai.withmb\\\\claude\\\\.claude\\\\worktrees\\\\sleepy-lamport\")"
    ]
  }
}
